---
import Base from "../layouts/Base.astro";
---

<Base>
	<div class="fixed top-0 right-0 bottom-0 left-0 flex">
		<div class="flex-none basis-[480px] p-1 border-r flex-col">
			<div class="flex-none basis-[120px] flex justify-center items-center">
				<ol>
					<li>위 첫번째 칸에 출발지점의 "업체명", "주소" 삽입</li>
					<li>두번째 칸부터 가야할 곳을 랜덤하게 삽입(엑셀에서 복&붙 하면 편함)</li>
					<li>출발지점 포함 최대 15개 입력만 가능</li>
					<li>표 아래 "최적경로 찾아줘" 버튼 클릭</li>
					<li><a href="https://namu.wiki/w/%EC%99%B8%ED%8C%90%EC%9B%90%20%EC%88%9C%ED%9A%8C%20%EB%AC%B8%EC%A0%9C">TSP</a> 알고리즘으로 최적 경로 판단(업체명 또는 주소칸이 비어있을 경우 그 줄은 무시)</li>
					<li>아래 표에 출발지점부터 방문해야할 순서대로 정렬됨</li>
					<li>만일, KAKAO 지도에서 인식못하는 주소 있을 경우, 붉은글씨로 에러</li>
				</ol>
			</div>
			<div class="grow shrink-0 basis-0">
				<div id="spreadsheet" class="w-full"></div>
				<div class="text-center mb-3">
					<button class="btn" id="findpath">최적경로 찾아줘</button>
				</div>
				<div id="msg"></div>
			</div>
		</div>
		<div class="grow shrink-0 basis-0 p-1">
			<div id="map" class="h-full w-full"></div>
		</div>
	</div>
</Base>

<script is:inline>

	const MAX_ROWS = 15;
	const MAX_COLS = 2;
	const el = document.getElementById("spreadsheet");
	const findpath = document.getElementById("findpath");
	const msg = document.getElementById("msg");
	const kakao_key = "5584c9f9d2b08e7975a38029e42d9790";

	const spreadsheet = jspreadsheet(el, {
		data: [],
		width: "100%",
		columns: [
			{ type: "text", title: "업체명", width: 90 },
			{ type: "text", title: "주소", width: el.clientWidth - 50 - 90 },
		],
		minDimensions: [2, 15],
		contextmenu: {},
		onbeforeinsertrow: function (_instance, rows) {
			if (rows => MAX_ROWS - 1) return false;
		},
		onbeforeinsertcolumn: function (_instance, columns) {
			if (columns => MAX_COLS - 1) return false;
		}
	});

	const map = document.getElementById("map");
	let markers = []; // 지도 마커들
	let routing = []; // 이동경로 좌표들
	let polyline = undefined; // 이동경로 좌표들로 만든 지도 표시용 객체
	const map_options = {
		center: new kakao.maps.LatLng(37.5820926424763, 126.888984720113),
		level: 7,
	};
	const kakao_map = new kakao.maps.Map(map, map_options);

	
	findpath.onclick = async (e) => {
		msg.innerHTML = "";
		let src = spreadsheet.getData();
		let tar = [];

		// 스프레드시트 스타일 초기화
		try {
			const all_tr = el.querySelectorAll("table tbody tr");
			for (let x of all_tr) x.classList.remove("warn");
		} catch(e) {
			msg.innerHTML = "스프레드시트에 기술적인 문제가 발생했습니다.";
			console.log(e);
			return;
		}

		// 지도 초기화 (기존 마커, 이동경로 삭제)
		try {
			markers.forEach((marker) => { marker.setMap(null); });
			polyline?.setMap(null);
			polyline = undefined;
			routing = [];
		} catch(e) {
			msg.innerHTML = "기존 마커/이동경로 삭제하는 과정에서 기술적인 문제가 발생했습니다.";
			console.log(e);
			return;
		}
		
		// 주소->좌표 변환
		try {
			for (let [i, [x, y]] of src.entries()) {
				if (x.trim().length === 0 || y.trim().length === 0) continue;

				let res = await fetch(`https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(y)}`, {
					method: "GET",
					headers: {
						Authorization: `KakaoAK ${kakao_key}`,
					}
				});
				let obj = await res.json();

				tar.push([i, x, y, obj?.documents?.[0]?.x, obj?.documents?.[0]?.y]);
			}
		} catch(e) {
			msg.innerHTML = "주소->좌표 변환하는 KAKAO MAP API에 뭔가 문제가 있습니다.";
			console.log(e);
			return;
		}

		// 변환된 좌표에 문제가 없는지 검사
		try {
			let is_err = false;

			for (let [i, _x, _y, z, _w] of tar) {
				if (z === undefined) {
					is_err = true;
					el.querySelector(`table tbody tr[data-y="${i}"]`).classList.add("warn");
				}
			}

			if (is_err) throw new Error("주소 오류");

		} catch(e) {
			msg.innerHTML = "카카오 지도가 인식을 못하는 주소가 있어 수정이 필요합니다.";
			console.log(e);
			return;
		}


		// tar 배열에 아무것도 없다면 그냥 종료
		if (tar.length === 0) return; 



		// TSP 알고리즘 적용
		try {

			msg.innerHTML = "최적 경로를 찾고 있습니다....";

			tar = solveTSP(tar);
			// console.log(tar);
			// console.log(res);
		} catch(e) {
			msg.innerHTML = "TSP 알고리즘 적용에 문제가 생겼습니다.";
			console.log(e);
			return;
		}

		// 최적경로를 스프레드시트에 다시 표시
		try {
			spreadsheet.setData(tar.map(([_i, a, b, _x, _y]) => [a, b]));

			msg.innerHTML = "최적 경로를 찾았습니다. 위부터 순서대로 방문하면 됩니다.";
		} catch(e) {
			msg.innerHTML = "스프레드시트에 기술적인 문제가 발생했습니다.";
			console.log(e);
			return;
		}
		
		// 실제 이동 경로 추적
		try {
			const body = {
				origin: { x: tar[0][3], y: tar[0][4] },
				destination: { x: tar[tar.length - 1][3], y: tar[tar.length - 1][4] },
				waypoints: tar.map(([_i, a, _b, x, y]) => ({ name: a, x: x, y: y })).slice(1, -1),
				priority: "RECOMMEND"
			};

			let res = await fetch('https://apis-navi.kakaomobility.com/v1/waypoints/directions', {
				method: 'POST',
				headers: {
					'Authorization': `KakaoAK ${kakao_key}`,
					'Content-Type': 'application/json'
				},
				body: JSON.stringify(body)
			});
			let obj = await res.json();

			// console.log(obj);

			let tmp = collectValuesByKey(obj, "vertexes");
			tmp = tmp.flat(Infinity);
			for (let i = 0; i < tmp.length; i += 2) {
				routing.push(new kakao.maps.LatLng(tmp[i + 1], tmp[i]));
			}
			
		} catch(e) {
			msg.innerHTML = "카카오 지도 이동 경로 API 에 기술적인 문제가 발생했습니다.";
			console.log(e);
			return;
		}

		// 지도에 마커/이동경로 표시
		try {
			kakao_map.panTo(new kakao.maps.LatLng(tar[0][4], tar[0][3]));

			markers = tar.map(([i, a, b, x, y]) => new kakao.maps.Marker({
				map: kakao_map,
				position: new kakao.maps.LatLng(y, x),
				title: a + "\n" + b,
			}));

			polyline = new kakao.maps.Polyline({
				map: kakao_map,
				path: routing,
				strokeWidth: 5,
				strokeColor: "#000000",
				strokeStyle: "solid",
				strokeOpacity: 0.6,
			});

		} catch(e) {
			msg.innerHTML = "카카오 지도 이동 경로 지도 표시에 기술적인 문제가 발생했습니다.";
			console.log(e);
			return;
		}
	};


	
	
	
</script>